{"meta":{"title":"奋斗的小鸟","subtitle":null,"description":null,"author":"奋斗的小鸟","url":"http://struggling-bird.cn"},"pages":[{"title":"关于","date":"2018-08-11T08:59:35.002Z","updated":"2018-08-11T08:59:34.705Z","comments":false,"path":"about/index.html","permalink":"http://struggling-bird.cn/about/index.html","excerpt":"","text":"致力于网站建设与后台服务设计。喜欢新事物，对新的技术有追求! 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; name: &apos;zhaokk&apos; age: 23, gender: &apos;男&apos;, profession: &apos;Web Developer &amp; Coder&apos;, experience: &apos;2年&apos;, address: &apos;陕西西安&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/zhaokuankuan&apos;, blog: &apos;https://blog.csdn.net/zhaokk_git&apos;, email: &apos;935068797@qq.com&apos;, description: &apos;愿半生戎码，归来仍为少年！&apos;, /** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\\ = /O * ____/`---&apos;\\____ * .&apos; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| &apos;&apos;\\---/&apos;&apos; | | * \\ .-\\__ `-` ___/-. / * ___`. .&apos; /--.--\\ `. . __ * .&quot;&quot; &apos;&lt; `.___\\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-&apos;====== * `=---=&apos; * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ * 佛祖保佑 永无BUG * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ */&#125;"},{"title":"个人项目","date":"2018-08-11T08:12:03.783Z","updated":"2018-08-11T08:12:03.721Z","comments":false,"path":"repository/index.html","permalink":"http://struggling-bird.cn/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-10T04:53:59.873Z","updated":"2018-08-07T08:29:54.577Z","comments":true,"path":"links/index.html","permalink":"http://struggling-bird.cn/links/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-08-11T08:18:11.497Z","updated":"2018-08-11T08:18:11.434Z","comments":true,"path":"categories/index.html","permalink":"http://struggling-bird.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-11T08:15:23.805Z","updated":"2018-08-11T08:15:23.493Z","comments":true,"path":"tags/index.html","permalink":"http://struggling-bird.cn/tags/index.html","excerpt":"","text":"aaaaa"}],"posts":[{"title":"Vue+Webpack+node构建web和App项目","slug":"Vue-Webpack-node构建web和App项目","date":"2018-08-11T10:16:02.000Z","updated":"2018-08-11T10:17:37.193Z","comments":true,"path":"2018/08/11/Vue-Webpack-node构建web和App项目/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/Vue-Webpack-node构建web和App项目/","excerpt":"","text":"先说一下，本猿自今年接触到vue之后，感到vue全家桶之大，不能穷也，虽然这个框架的越来越成熟，越来越多的对应的组件框架伴随而出，例如，web端的elementUI,移动端的mintUi等。本猿在学习和使用了半年之久，然后粗略的总结下搭建和使用的过程，方便自己以后继续深入学习和帮助一下刚入门的新猿们。 这次主要是以APP端的mintUI为例子讲解下，其实web端的elementUI和这个基本使用的方式一样。 一.环境的准备 node ， vue ，mintUI 首先下载node。 js.Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。(介绍来自百度) 下载完成之后可以在dos中输入： node -v 和 npm -v查看你所安装的node的版本，一般情况下你在安装好node后，自动就给你安装好了npm。 接下来你需要安装淘宝镜像，具体的原因你可以百度，这里给小白说下，你不安装也是可以的，默认是npm是国外的，cnpm是国内的(淘宝)。npm install -g cnpm -registry=https://registry.npm.taobao.org 安装完淘宝的镜像之后就可以安装Webpack了，我这里用cnpm装 cnpm install webpack -g 。(介绍来自百度) webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。 安装完Webpack之后，现在就是安装vue的脚手架了，cnpm install vue-cli -g（给你们个建议，基本上我是在我需要创建项目的目录下安装这个脚手架的）。 接下来就是见证奇迹的时刻了，就是创建我们的项目了，这个你想存放在哪个目录，你就cd到哪个目录之下执行， vue init webpack 项目名称。 然后你会进入一个引导的目录，根据目录填写你的项目名称和是否使用路由等。 上面这个图来自网络，可以按照这个配置。到此所有的创建工作就全部完成了，然后 cd 到该项目底下 npm run dev ，在浏览器中localhost：8080 就可以看见你新创建的项目。 二.下面上一下这个项目的目录结构 12345678910111213141516171819202122├── build --------------------------------- webpack相关配置文件│ ├── build.js --------------------------webpack打包配置文件│ ├── check-versions.js ------------------------------ 检查npm,nodejs版本│ ├── dev-client.js ---------------------------------- 设置环境│ ├── dev-server.js ---------------------------------- 创建express服务器，配置中间件，启动可热重载的服务器，用于开发项目│ ├── utils.js --------------------------------------- 配置资源路径，配置css加载器│ ├── vue-loader.conf.js ----------------------------- 配置css加载器等│ ├── webpack.base.conf.js --------------------------- webpack基本配置│ ├── webpack.dev.conf.js ---------------------------- 用于开发的webpack设置│ ├── webpack.prod.conf.js --------------------------- 用于打包的webpack设置├── config ---------------------------------- 配置文件├── node_modules ---------------------------- 存放依赖的目录├── src ------------------------------------- 源码│ ├── assets ------------------------------ 静态文件│ ├── components -------------------------- 组件│ ├── main.js ----------------------------- 主js│ ├── App.vue ----------------------------- 项目入口组件│ ├── router ------------------------------ 路由├── package.json ---------------------------- node配置文件├── .babelrc--------------------------------- babel配置文件├── .editorconfig---------------------------- 编辑器配置├── .gitignore------------------------------- 配置git可忽略的文件 到现在这个项目只是搭建好了一个Vue的架子，我们需要把我们需要的插件引入，可以利用 cnpm install 插件名称 导入插件，我这里导入一下mintUI的插件 cnpm install –save mint-ui 然后需要在main.js中引入刚才导入的mintui和css。这个是mintUI的官网 import MintUI from ‘mint-ui’ import ‘mint-ui/lib/style.css’ Vue.use(MintUI)三.做好了准备工作，接下来就是我们的第一个项目了 直接上几张效果图。 这个有一个校验当没有账号和密码的时候，会提示让你填写，有的话就会跳转到这 然后我把我的代码上传到github上，你们可以down。https://github.com/zhaokuankuan/app.git 提示一下，你们在安装的时候需要安装好node 然后 cd到down下来的目录下，cnpm install 就安装完成好所有的jar包，然后npm run dev就可以了。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://struggling-bird.cn/categories/Web前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://struggling-bird.cn/tags/Vue/"},{"name":"Node","slug":"Node","permalink":"http://struggling-bird.cn/tags/Node/"},{"name":"Webpack","slug":"Webpack","permalink":"http://struggling-bird.cn/tags/Webpack/"}]},{"title":"springboot项目的搭建和基本的用法","slug":"springboot项目的搭建和基本的用法","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:04:31.386Z","comments":true,"path":"2018/08/11/springboot项目的搭建和基本的用法/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/springboot项目的搭建和基本的用法/","excerpt":"","text":"初涉springboot，学习小记，用于学习，简单介绍下如何去创建一个简单的的springboot工程。本人这里使用idea操作的。一.首先需要创建一个工程：new project,选择Spring Initalizr。输入项目的目录结构和项目的名称，如图：然后选择你需要导入的jar包，如下：web是web项目的核心启动包，devtools是一个web项目的工具包。 二.然后你的一个springboot项目便创建完成。如图我们可以创建这个项目的目录结构，但是需要注意一点的是，包的结构必须和TestApplication是在一级上。 在controller里面创建一个类，HelloController 123456789@RestControllerpublic class HelloController &#123; @RequestMapping(value = &quot;/hello&quot;) public String sayHello()&#123; return &quot;Hello , my First demo!&quot;; &#125;&#125; 然后我们启动这个工程，然后访问一下！如上图所示我们的项目就已经构建完成了，然后具体的项目的热部署和项目的过滤器和测试等都在我下面的笔记中有，也可以看我的github，查看我的代码！ 笔记： 1.springboot的创建： idea的情况下，选择Spring Initializr 然后配置 web 和 devtools 一个是启动的web的核心依赖一个是开发工具包2.创建热部署 idea下，pom中修改 devtools的optional为true 则为热部署开启 plugin 下增加configuration –》fork 为true 接下来在build里面选择自动构建；ctrl+shift+a：输入register窜则compile.automake.allow.when.app.running3.单元测试 先创建mockmvc，静态的加载：ockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); mockmvc.perform()调用mockmvcRequestBuilders.post/get方法，.parm()加参数–》键值对类型,anddo（print()）可以打印4json的支持 在 Spring Boot 体系中，天然对 Json 支持，@restController5.请求传参 例如@RequestMapping(value=”get/{name}”, method=RequestMethod.GET) public User get(@PathVariable String name){ this.name = name; }6.参数校验 实体类上可以加@NotEmpty，@Max，@Min，@Length来设置属性的校验 Spring Boot 的参数校验其实是依赖于 hibernate-validator 来进行 public void saveUser(@Valid Useruser,BindingResult result){ List list =result.getAllErrors(); //能够得到所有的校验的结果 }7.自定义过滤 自定义的过滤必须实现Filter接口并实现方法，在doFilter里面写上自己的过滤处理 @Configuration说明是个配置类，用来存放配置信息， @bean 说明该方法作为一个配置信息被spring监控， public FilterRegistrationBean testFilterRegistration() { FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new MyFilter()); registration.addUrlPatterns(“/*”); registration.addInitParameter(“paramName”, “paramValue”); registration.setName(“MyFilter”); registration.setOrder(1); return registration; } 代码地址","categories":[{"name":"微服务架构","slug":"微服务架构","permalink":"http://struggling-bird.cn/categories/微服务架构/"}],"tags":[{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"},{"name":"Springboot","slug":"Springboot","permalink":"http://struggling-bird.cn/tags/Springboot/"}]},{"title":"Springcloud微服务架构之断路器(Hystrix)","slug":"Springcloud微服务架构之断路器-Hystrix","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:04:39.921Z","comments":true,"path":"2018/08/11/Springcloud微服务架构之断路器-Hystrix/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/Springcloud微服务架构之断路器-Hystrix/","excerpt":"","text":"在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用，详细使用见上一章。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。为了将这种影响降到最低，提出了断路器的概念一． 断路器介绍Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。当较底层的服务出现故障时，会导致连锁故障。当一个服务的不可用达到一定的阈值断路器将会被打开。断路打开后，可用避免连锁故障，fallback方法返回一个出现故障时的处理方法二． 接下来便分别对Ribbon+resttemplate和feign两种消费服务的方式分别使用断路器进行说明。在此应该首先启动上一节中的服务注册中心和需要注册的服务server和service。Server的端口号是8761，server1和server2的端口号分别是8762和8763。三． 在Ribbon+resttemplate中使用断路器a) 需要先引入断路器的依赖包，如下 123456&lt;!--断路器的依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; b) 在程序的启动类中开启断路器的注解 1234567891011121314@SpringBootApplication@EnableHystrixpublic class RibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; c) 修改调用服务的方法Service，如下： 123456789101112131415@Servicepublic class service &#123; @Autowired private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = &quot;hasError&quot; ) public String sayHello(String name)&#123; return this.restTemplate.getForObject(&quot;http://service-hi/hi?name=&quot; + name,String.class); &#125; public String hasError(String name)&#123; return &quot;I have a error, so You must restart me!&quot; + name; &#125;&#125; d) 然后停掉第一步启动的两个service1和service2,再次访问http://localhost:8080/hello?name=kk，会出现如下图的界面 即，断路器增加成功！当你再次启动一个服务，如server1时，访问上述地址，会得到如下的图示： 四． 在feign中使用断路器：Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：feign.hystrix.enabled=truea) 这个只需要修改接口即可，在上节的基础上我们修改Iserver，首先需要创建一个类实现Iservice接口的方法，如下： 123456public class IserviceImpl implements Iservice &#123; @Override public String SayHello(String name) &#123; return &quot;I have a error, so You must restart me!&quot; + name; &#125;&#125; b) 然后在修改Iservice中修该fallback指向刚才的实现类，当出现断路时会调用实现类中的方法。 1234567@FeignClient(value = &quot;service-hi&quot;,fallback = IserviceImpl.class)@Servicepublic interface Iservice &#123; @RequestMapping(&quot;/hi&quot;) String SayHello(@RequestParam(value = &quot;name&quot;) String name);&#125; c) 然后访问，出现我们负载均衡的调用service1和service2，如下图： d) 然后我们停掉service2和service2，再次访问上述的路径，会出现如下图的显示，即说明断路器发挥了作用。 五. 断路器仪表盘 这里ribbon和feign两中方式都可以进行，我这里以feign为例，ribbon的和这个一样。a) 首先我们需要在pom中引入，该仪表盘的依赖，如下：123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;version&gt;1.4.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; b) 然后在Application上加上注释，开启注解 123456789@SpringBootApplication@EnableFeignClients@EnableHystrixDashboardpublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class, args); &#125;&#125; 然后启动feign,访问该网址http://localhost:8080/hystrix，出现图示的界面， 附上我的完整的博文：从零开始学习SpringCloud代码地址在此感谢，两位大佬的博客，我是根据以上大佬的博客学习的！方志鹏的springcloud微服务架构纯洁的微笑","categories":[{"name":"微服务架构","slug":"微服务架构","permalink":"http://struggling-bird.cn/categories/微服务架构/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://struggling-bird.cn/tags/SpringCloud/"},{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"}]},{"title":"Springcloud微服务架构之路由网关(zuul)","slug":"Springcloud微服务架构之路由网关(zuul)","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:05:08.176Z","comments":true,"path":"2018/08/11/Springcloud微服务架构之路由网关(zuul)/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/Springcloud微服务架构之路由网关(zuul)/","excerpt":"","text":"Springcloud微服务架构之路由网关(zuul) Zuul的主要功能是路由转发和过滤器: 1.路由功能是微服务的一部分，比如将 API-A转发到service-hi服务,zuul默认和Ribbon结合 实现了负载均衡的功能。 2.zuul不仅只是路由，并且还能过滤，做一些安全验证。 一． 接下来我们分别看一下，Zuul的路由转发和过滤器 首先还是在上一节的服务的注册和发现的基础上进行的，我们需要先启动Server(服务的注册中心):8761，然后启动我们的一个服务Service(需要注册的服务):8762。二． 路由转发：路由功能是微服务的一部分，比如将API-A转发到service-hia) 创建一个module项目rest-client b) 然后新建一个appliacation.yml,配置内容如下，我们将这个服务注册进eureka注册中心中，然后设置zuul的路由，当访问API-A 的时候我们将请求的理由到service-HI服务中去。 1234567891011121314server: port: 8088eureka: client: service-url: defaultZone: http://localhost:8761/eurekaspring: application: name: service-zuulzuul: routes: API-A: path: /API-A/** serviceId: SERVICE-HI c) 然后我们修改RestClientApplication 这个类，增加zuul开启路由的注解 12345678@SpringBootApplication@EnableZuulProxy@EnableEurekaClientpublic class RestClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RestClientApplication.class, args); &#125;&#125; d) 分别访问http://localhost:8761/你会看到如下的图示，有我们注入的zuul和需要路由的serice-hi服务。 在访问http://localhost:8088/API-A/hello?name=kk，你会看到，我们的如图所示，即我们的路由已经成功的将api-a转发到了serive-hi的服务，并且输出了service-hi的端口，具体的代码可以看文章的结尾。 三 过滤功能：zuul不仅可以做为路由使用，还可以用作过滤来做一些逻辑操作a) 在上面的基础上进行改造，创建一个类MyFilter具体的说明已经注释出来了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author :zhaokk * @date: 2018/5/11 - 14:58 */@Componentpublic class MyFilter extends ZuulFilter &#123; private static Logger logger = LoggerFactory.getLogger(ZuulFilter.class); @Override public String filterType() &#123; return &quot;pre&quot;; //pre：路由之前 //routing：路由之时 //post： 路由之后 //error：发送错误调用 &#125; @Override public int filterOrder() &#123; return 0; //优先级 0 最高 &#125; @Override public boolean shouldFilter() &#123; return true; //true为永远过滤 &#125; @Override public Object run() throws ZuulException &#123; RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletRequest httpServletRequest = requestContext.getRequest(); Object o = httpServletRequest.getParameter(&quot;token&quot;); if(o == null)&#123; logger.warn(&quot;token is empty&quot;); requestContext.setSendZuulResponse(false); requestContext.setResponseStatusCode(401); try &#123; requestContext.getResponse().getWriter().write(&quot;token is empty!&quot;); &#125;catch (Throwable throwable)&#123; return null; &#125; &#125; logger.info(&quot;ok&quot;); return null; &#125;&#125; b) 然后我们继续访问http://localhost:8088/API-A/hello?name=kk，这时你会看到，界面如图，因为我们的代码中获取不到token，所以被拦截了， c） 当我们输入http://localhost:8088/API-A/hello?name=kk&amp;token=22，会显示 如下的界面，即我们的过滤功能有效了！ 附上我的完整的博文：从零开始学习SpringCloud代码地址在此感谢，两位大佬的博客，我是根据以上大佬的博客学习的！ 方志鹏的springcloud微服务架构 纯洁的微笑","categories":[{"name":"微服务架构","slug":"微服务架构","permalink":"http://struggling-bird.cn/categories/微服务架构/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://struggling-bird.cn/tags/SpringCloud/"},{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"}]},{"title":"亲测javaWeb的Excel的文件导入","slug":"亲测javaWeb的Excel的文件导入","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:21:58.326Z","comments":true,"path":"2018/08/11/亲测javaWeb的Excel的文件导入/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/亲测javaWeb的Excel的文件导入/","excerpt":"","text":"最近在做一个web项目，需要写一个Excel文件的导入，由于本猿是个刚入行不就的萌新，所以找到了一些文章研究了一下，但是讲的都比较混乱，于是在一边借阅一边的摸索中完成了导入，先说一下思路： 1.首先是将需要导入的文档转换成流的形式。 2.判断excel文件的类型是.xlsx还是.xls格式的，将对应的格式转换成Workbook所对应的格式，到了此处基本上一个excl文件就已经被导入了，并且存储为对应的excl格式了。 3.此方法workbook.getSheetAt()可以得到你的这个文件上的所有的sheet，我的sheet默认只有一个所以我直接取的是sheet(0)。 4.然后遍历此sheet得到所有的Row，将每行的数据add到list中并且返回。 5.然后遍历每一行的，得到对应的元素上的信息，这里需要注意一下，这个row.getCell(0)方法是从0开始的，然后就得到了你所需要到倒数的数据了，剩下的事情就是业务的处理啦。 下来我上一下，我的具体的做法。 一.环境和所需要引入的jar包。 环境： ssm+maven 具体的文件的上传可以查看我的上一篇博客 基于springMVC的文件上传和下载 这里需要注意的是这里我们需要引入支持解析excl的工具类poi，我是直接maven直接导入的，如下： 123456789101112131415161718192021&lt;!-- 导入和导出excel时需要的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.xmlbeans&lt;/groupId&gt; &lt;artifactId&gt;xmlbeans&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; 到此，前期的环境的准备工作就已经全部完成了。二.代码 导入的方法的接口这里需要注意下，这里的Result的是我自己定义的一个类，你们在引用的时候自己重写下就可以了，用Object就可以，返回个map就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import com.yonyouFintech.yangfan.commons.Result;import com.yonyouFintech.yangfan.commons.util.DateUtil;import com.yonyouFintech.yangfan.commons.util.ExcelUtil;import com.yonyouFintech.yangfan.domain.YfBibliographic;import com.yonyouFintech.yangfan.service.YfBibliographicService;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.InputStream;import java.util.ArrayList;import java.util.List;@RestControllerpublic class yfImportExclController &#123; @Autowired private YfBibliographicService yfBibliographicService; @RequestMapping(value = &quot;/exclImport&quot;,method = RequestMethod.POST) public Result importExcl(@RequestParam(&quot;file&quot;) MultipartFile excl, HttpServletRequest request)&#123; Result result = new Result(); if(!excl.isEmpty())&#123;//说明文件不为空 try &#123; String fileName = excl.getOriginalFilename(); InputStream is = excl.getInputStream();//转化为流的形式 List&lt;YfBibliographic&gt; listMer = new ArrayList&lt;YfBibliographic&gt;(); List&lt;Row&gt; list = ExcelUtil.getExcelRead(fileName,is, true); //首先是读取行 也就是一行一行读，然后在取到列，遍历行里面的行，根据行得到列的值 for (Row row : list) &#123; /****************得到每个元素的值start**********************/ Cell cell_0 = row.getCell(0); Cell cell_1 = row.getCell(1); Cell cell_2 = row.getCell(2); Cell cell_3 = row.getCell(3); /*****************得到每个元素的值end**********************/ /******************解析每个元素的值start*******************/ //得到列的值，也就是你需要解析的字段的值 String bookName = ExcelUtil.getValue(cell_0); String editor = ExcelUtil.getValue(cell_1); String express = ExcelUtil.getValue(cell_2); String version = ExcelUtil.getValue(cell_3); /******************解析每个元素的值end*******************/ /****************将读取出来的数值进行包装start***********/ YfBibliographic yfBibliographic = new YfBibliographic(); yfBibliographic.setName(bookName); yfBibliographic.setAuthor(editor); yfBibliographic.setPress(express); yfBibliographic.setEdition(version); yfBibliographic.setStatus(&quot;1&quot;); yfBibliographic.setExtend1(DateUtil.getCurDateStr()); listMer.add(yfBibliographic); /**************将读取出来的数值进行包装end**************/ &#125; if(listMer.size()&gt;0)&#123; for (YfBibliographic item:listMer) &#123; yfBibliographicService.insertYfBibliographic(item); &#125; &#125; result.setSuccess(true); result.setSuccessMessage(&quot;导入成功！&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); result.setSuccess(false); result.setErrorMessage(&quot;导入出现异常！&quot;); &#125; &#125;else&#123; result.setSuccess(false); result.setErrorMessage(&quot;导入的文件为空！&quot;); &#125; return result; &#125;&#125; 判断文件类型的工具类123456789101112131415161718192021222324252627282930313233343536/** * @author zhaokk * @Date 2017-12-01 * 工具类验证Excel文档 */public class WDWUtil &#123; /** * @描述：是否是2003的excel，返回true是2003 * @param filePath * @return */ public static boolean isExcel2003(String filePath) &#123; return filePath.matches(&quot;^.+\\\\.(?i)(xls)$&quot;); &#125; /** * @描述：是否是2007的excel，返回true是2007 * @param filePath * @return */ public static boolean isExcel2007(String filePath) &#123; return filePath.matches(&quot;^.+\\\\.(?i)(xlsx)$&quot;); &#125; /** * 验证是否是EXCEL文件 * @param filePath * @return */ public static boolean validateExcel(String filePath)&#123; if (filePath == null || !(isExcel2003(filePath) || isExcel2007(filePath)))&#123; return false; &#125; return true; &#125;&#125; 获取excel表格，每行的数据的类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.InputStream;import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;public class ExcelUtil &#123; //读取文件的方法 /** * 获取解析文件行数据 * @param fileName : 文件地址 * @param isTitle : 是否过滤第一行解析 * @return * @throws Exception */ public static List&lt;Row&gt; getExcelRead(String fileName, InputStream is, boolean isTitle) throws Exception&#123; try &#123; //判断其兼容版本 调用了判断版本的方法 Workbook workbook = getWorkbook(fileName,is); Sheet sheet = workbook.getSheetAt(0); int count = 0; List&lt;Row&gt; list = new ArrayList&lt;Row&gt;(); for (Row row : sheet) &#123; // 跳过第一行的目录 if (count == 0 &amp;&amp; isTitle) &#123; count++; continue; &#125; list.add(row); &#125; return list; &#125; catch (Exception e) &#123; throw e; &#125; &#125;//判断版本的方法 public static Workbook getWorkbook(String fileName,InputStream is) throws Exception&#123; Workbook workbook = null; try &#123; /** 判断文件的类型，是2003还是2007 */ boolean isExcel2003 = true; if (WDWUtil.isExcel2007(fileName)) &#123; isExcel2003 = false; &#125; if (isExcel2003) &#123; workbook = new HSSFWorkbook(is); &#125; else &#123; workbook = new XSSFWorkbook(is); &#125; &#125; catch (Exception e) &#123; throw e; &#125; return workbook; &#125; //得到celL值的方法： public static String getValue(Cell cell)&#123; if(cell.getCellType() == HSSFCell.CELL_TYPE_BOOLEAN)&#123; return String.valueOf(cell.getBooleanCellValue()); &#125;else if(cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC)&#123; double value = cell.getNumericCellValue(); return new BigDecimal(value).toString(); &#125;else if (cell.getCellType() ==HSSFCell.CELL_TYPE_STRING)&#123; return String.valueOf(cell.getStringCellValue()); &#125;else&#123; return String.valueOf(cell.getStringCellValue()); &#125; &#125;&#125; 以上，就是本猿的导入的方法和思路，亲测有效，完美运行，作为一个新手猿，可能会有很多不足，请诸君在阅览的时候，发现有不足的地方请多多指教，转载请注明出处。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://struggling-bird.cn/categories/JavaWeb/"}],"tags":[{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://struggling-bird.cn/tags/Spring/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"http://struggling-bird.cn/tags/SpringMvc/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://struggling-bird.cn/tags/MyBatis/"},{"name":"POI","slug":"POI","permalink":"http://struggling-bird.cn/tags/POI/"}]},{"title":"Springcloud微服务架构之服务的注册和发现","slug":"Springcloud微服务架构之服务的注册和发现","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T11:20:34.497Z","comments":true,"path":"2018/08/11/Springcloud微服务架构之服务的注册和发现/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/Springcloud微服务架构之服务的注册和发现/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务可以在”自己的程序”中运行，并通过”轻量级设备与HTTP型API进行沟通”。关键在于该服务可以在自己的程序中运行。通过这一点我们就可以将服务公开与微服务架构(在现有系统中分布一个API)区分开来。在服务公开中，许多服务都可以被内部独立进程所限制。如果其中任何一个服务需要增加某种功能，那么就必须缩小进程范围。在微服务架构中，只需要在特定的某种服务中增加所需功能，而不影响整体进程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上解释来自百度，综上可以看出对于微服务架构来说，服务的注册和服务的发现就很关键了，由于本人接触Dubbo和zookeeper较少因此谈谈Springcloud的注册和发现把。一.新建一个空的maven工程（任何东西都不选)如图 Next： 然后填写 GroupId 和 ArtifactId 分别写入的是 包的层次结构基本上是公司的域名或者项目的域名。例 com.kk 或者 com.baidu等二.在新建好的该maven项目中新建两个module分别为server和service作为服务的注册中心和服务的提供方(创建方法类似)。注册中心选择server , 服务提供者选择discovery三.Server的配置，创建一个application.yml文件然后配置yml 12345678910server: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false #表示是否将自己注册到Eureka Server fetch-registry: false #表示是否从Eureka Server获取注册信息 service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #注册中心的地址 然后启动server的这个项目，访问http://localhost:8761/ 你就看到如下的界面说明注册中心已经配置完成，只是里面没有注册服务。Ps：在这里说一下，因为我们在做分布式部署的时候为了保证项目的健壮性我们通常会采用集群部署，因为可以参考微笑的博客来设置注册中心的集群。四.接下来我们应该向注册中心注册服务了，首先创建application.yml文件 123456789在ServiceApplication类中开启服务发现的注解@SpringBootApplication@EnableEurekaClientpublic class ServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceApplication.class, args); &#125;&#125; 然后配置yml 12345678`server: port: 8762 #设置服务的端口号client: serviceUrl: defaultZone: http://localhost:8761/eureka/spring: application: name: service-A `然后再次访问注册中心，你就发现我们的服务已经注册进去了。到此，springcloud的服务的注册和发现已经完成。在此感谢，两位大佬的博客，我是根据以上大佬的博客学习的！方志鹏的springcloud微服务架构纯洁的微笑","categories":[{"name":"微服务架构","slug":"微服务架构","permalink":"http://struggling-bird.cn/categories/微服务架构/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://struggling-bird.cn/tags/SpringCloud/"},{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"}]},{"title":"SpringCloud微服务架构之服务的调用","slug":"SpringCloud微服务架构之服务的调用","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:04:56.133Z","comments":true,"path":"2018/08/11/SpringCloud微服务架构之服务的调用/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/SpringCloud微服务架构之服务的调用/","excerpt":"","text":"微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。接下来分别对这两种的进行讲解。服务的调用还是在上一节服务的注册和发现的基础上进行的。一． 准备工作，服务的调用基于上一节，服务的注册和发现进行的，因此我们需要先启动上一节的服务注册中心，然后再启动我们需要注册的服务service-hi,然后修改service 的端口号重新启动，访问http://localhost:8761/，你会看到如下图则表示我们的准备工作已经完成了。 二． 创建一个基于Ribbon+restTemplate的服务消费者：ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。 新建一个module，分别引入如下的包，然后finish 2.新建好了之后，RibbonApplication中增加注解@bean 将RestTemplate注入到容器中去， 12345678910111213@SpringBootApplicationpublic class RibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 3，然后创建一个service类和一个controller类，如图 1234567891011@Servicepublic class service &#123; @Autowired private RestTemplate restTemplate; public String sayHello(String name)&#123; return this.restTemplate.getForObject(&quot;http://service-hi/hi?name=&quot; + name,String.class); &#125;&#125; Service中需要注入的是resttemplate接口,并且可以去访问对应的服务和服务的接口。在创建一个 123456789101112@RestControllerpublic class controller &#123; @Autowired private service service; @RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;) public String sayHello(String name)&#123; return service.sayHello(name); &#125;&#125; 4，接下来我们需要修改下我们前一节所写的服务，如图： 1234567891011121314151617@SpringBootApplication@EnableDiscoveryClient@RestControllerpublic class ServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceApplication.class, args); &#125; @Value(&quot;$&#123;server.port&#125;&quot;) String port; @RequestMapping(value = &quot;/hi&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;) public String sayHello(String name)&#123; return &quot;I am service-hi ,my port is :&quot; + port + &quot;my name is &quot; + name; &#125;&#125; 5，然后一次重启所有的服务：serverservice1service2Ribbon,然后访问http://localhost:8080/hello?name=kk,你会发现界面上会重复交替出现两个服务service1和service2的端口号和传递过去的参数。 到此Ribbon和restTemplate的消费服务已经完成，接下来我们看看Feign的服务。三． 创建一个基于Feign去消费服务：Feign 采用的是基于接口的注解Feign 整合了ribbon1.同理我们也是需要在一的步骤下进行的，必须先开启服务注册中心，并且将我们的服务注册进去，然后新建一个Feign，如图： 然后需要创建一个Iservice接口和FeignController类:创建该接口用来调用服务@FeignClient(value = “service-hi”) 注解配置的是服务的名称 12345678@RequestMapping(&quot;/hi&quot;) //配置的调用的接口@FeignClient(value = &quot;service-hi&quot;)@Servicepublic interface Iservice &#123; @RequestMapping(&quot;/hi&quot;) String SayHello(@RequestParam(value = &quot;name&quot;) String name);&#125; 123456789101112@RestControllerpublic class FeignController &#123; @Autowired private Iservice iservice; @RequestMapping(value = &quot;/feign/hello&quot;) public String sayHello(String name)&#123; return iservice.SayHello(name); &#125;&#125; 配置下该启动类，如下： 12345678@SpringBootApplication@EnableFeignClientspublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class, args); &#125;&#125; 然后访问：http://localhost:8080/feign/hello?name=kk你会看到如下的界面： 以上就是服务的消费的两种方式。 附上我的完整的博文：从零开始学习SpringCloud代码地址在此感谢，两位大佬的博客，我是根据以上大佬的博客学习的！方志鹏的springcloud微服务架构纯洁的微笑","categories":[{"name":"微服务架构","slug":"微服务架构","permalink":"http://struggling-bird.cn/categories/微服务架构/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://struggling-bird.cn/tags/SpringCloud/"},{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"}]},{"title":"从零开始学习SpringCloud","slug":"从零开始学习SpringCloud","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:05:25.326Z","comments":true,"path":"2018/08/11/从零开始学习SpringCloud/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/从零开始学习SpringCloud/","excerpt":"","text":"&#160; &#160; &#160;前段时间把SpringBoot刷了一遍，感觉是时候深入研究一下微服务架构了，在网上看到了方志鹏的书，觉得不错便关注了他的博客，由于前期一直关注微笑并且跟着微笑的达人课完成了SpringBoot的入门，因此在此感谢两位大佬，令附上两位大佬的博客地址。 ==》springboot的入门 &#160; &#160; &#160;我将springcloud处理微服务架构分为下面的模块进行慢慢的蚕食： &#160; &#160; &#160;1. 服务的注册和发现 &#160; &#160; &#160;2. 断路器 &#160; &#160; &#160;3. 服务调用&#160; &#160; &#160;4. 路由网关 &#160; &#160; &#160;5. 分布式配置中心 &#160; &#160; &#160;6. 消息总线 &#160; &#160; &#160;7. 服务链路追踪 &#160; &#160; &#160; &#160; &#160; &#160;未完待续中。。。 &#160; &#160; &#160;附上我的github地址，从零开始学习springcloud 以下是我自己对上述模块的认识和分析： &#160; &#160; &#160;1. 在服务的注册和发现和调用之间有三个模块： 注册中心,服务提供者，服务消费者 &#160;&#160; &#160;2. 启动的时候先启动注册中心==》提供者==》消费者 &#160; &#160;&#160;3.可以对注册中心进行负载均衡也可以对服务的调用进行负载均衡对注册中心：通过修改 defaultZone: http://localhost:8761/eureka/，http://localhost:8762/eureka/，http://localhost:8763/eureka/来实现&#160; &#160; &#160;对服务的调用： ribbon + resttmplate 是客户端的一种负载均衡的方式&#160; &#160; &#160;feign :原理也是基于ribbon实现的。只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。&#160; &#160; &#160;4.断路器：为了保证服务的高可用，引入了断路器的概念，当访问一个服务的不可用得到了一定的阈值时，断路器将会被打开 &#160; &#160; &#160;两种实现： &#160; &#160; &#160; (1).restTemplate 和 ribbon 方式，需要在调用的服务上增加熔断的方法即可 &#160; &#160; &#160; (2).feign，需要在接口的FeignClient注解中增加callback方法即可，指向该接口的实现类，该实现类中重写的方法即出现断路时调用的方法。&#160; &#160; &#160;5.路由网关(zuul)：主要做的是路由的转发和过滤，zuul默认和Ribbon结合实现了负载均衡的功能。 &#160; &#160; &#160; (1).路由的转发，类似于nigix反向代理，将对应的路径代理到对应的服务器上去 &#160; &#160; &#160; (2).路由的过滤，通过自定义过滤器，然后继承zuulfilter来自定义过滤的类型和优先级和逻辑等 &#160; &#160;&#160;6.分布式配置中心(Configure)：在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件 &#160; &#160; &#160; 分为两个角色：分别是配置的服务器和配置的客户端 &#160; &#160; &#160;延伸到微服务可以将配置中心做成一个微服务，并且将其集群 &#160; &#160;&#160;7.消息总线(Bus)：消息总线将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控 &#160; &#160; &#160;主要是rabbitmq的用法 &#160; &#160; &#160;8.服务链路追踪(Sleuth):在分布式系统中提供追踪解决方案 &#160; &#160; &#160; 对于微服务架构，启动的时候会启动一个Trace，一系列spans组成的一个树状结构 &#160; &#160; &#160; 在访问的时候会跟随目前访问的位置和所用的时间，可以快速的反应和查找问题 &#160; &#160; &#160; ZipkinServer ==》用来收集调用信息 &#160; &#160; &#160; 9.docker部署springcloud项目 &#160; &#160;&#160;10.服务注册(consul):它是一个提供服务发现和配置的工具,consul具有分布式、高可用、高扩展性。 以上学习资源来自：方志鹏的springcloud微服务架构纯洁的微笑","categories":[{"name":"微服务架构","slug":"微服务架构","permalink":"http://struggling-bird.cn/categories/微服务架构/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://struggling-bird.cn/tags/SpringCloud/"},{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"}]},{"title":"java后台实现生成二维码并且上传的详细介绍","slug":"java后台实现生成二维码并且上传的详细介绍","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:01:00.239Z","comments":true,"path":"2018/08/11/java后台实现生成二维码并且上传的详细介绍/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/java后台实现生成二维码并且上传的详细介绍/","excerpt":"","text":"今天又遇到了新的问题，就是后台需要生成一个二维码，以前从来没有做过这个二维码，通过上午的努力，总算是完成了，希望有兴趣的可以一起交流学习。我用的是google.zxing的这个插件来完成生成二维码的，还是很方便的。 一.首先需要引入google.zxing的jar包。 我是建的maven工程，因此直接给你上maven的配置，别的可以在网上下载相应的jar包也行。pom.xml配置如下：12345678910111213&lt;!-- 二维码 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt; 二.接下来直接上代码： 就是先将需要放在二维码中的数据传进来，生成二维码，然后在将二维码写进一个img中，最后是将这个图片放在了服务器上，然后这个二维码就完成了生成和上传，这次由于项目比较着急，没有时间去研究如何加水印，有兴趣的可以去研究下。 具体的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private static final int BLACK = 0xff000000; private static final int WHITE = 0xFFFFFFFF; /** * @param args */ public static String tomakeMode(String strJson,String path) &#123; QsMode test = new QsMode(); String filePostfix=&quot;png&quot;; String UUID = StringUtil.getUUID(); File file = new File(path +UUID + &quot;.&quot;+filePostfix); test.encode(strJson, file,filePostfix, BarcodeFormat.QR_CODE, 5000, 5000, null); return UUID+&quot;.png&quot;; &#125; /** * 生成QRCode二维码&lt;br&gt; * 在编码时需要将com.google.zxing.qrcode.encoder.Encoder.java中的&lt;br&gt; * static final String DEFAULT_BYTE_MODE_ENCODING = &quot;ISO8859-1&quot;;&lt;br&gt; * 修改为UTF-8，否则中文编译后解析不了&lt;br&gt; * @param contents 二维码的内容 * @param file 二维码保存的路径，如：C://test_QR_CODE.png * @param filePostfix 生成二维码图片的格式：png,jpeg,gif等格式 * @param format qrcode码的生成格式 * @param width 图片宽度 * @param height 图片高度 * @param hints */ public void encode(String contents, File file,String filePostfix, BarcodeFormat format, int width, int height, Map&lt;EncodeHintType, ?&gt; hints) &#123; try &#123; contents = new String(contents.getBytes(&quot;UTF-8&quot;), &quot;ISO-8859-1&quot;); BitMatrix bitMatrix = new MultiFormatWriter().encode(contents, format, width, height); writeToFile(bitMatrix, filePostfix, file); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 生成二维码图片&lt;br&gt; * * @param matrix * @param format * 图片格式 * @param file * 生成二维码图片位置 * @throws IOException */ public static void writeToFile(BitMatrix matrix, String format, File file) throws IOException &#123; BufferedImage image = toBufferedImage(matrix); ImageIO.write(image, format, file); &#125; /** * 生成二维码内容&lt;br&gt; * * @param matrix * @return */ public static BufferedImage toBufferedImage(BitMatrix matrix) &#123; int width = matrix.getWidth(); int height = matrix.getHeight(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); for (int x = 0; x &lt; width; x++) &#123; for (int y = 0; y &lt; height; y++) &#123; image.setRGB(x, y, matrix.get(x, y) == true ? BLACK : WHITE); &#125; &#125; return image; &#125; strJson是我向二维码中存入的数据，path是我的存放这个生成的二维码的路径，我是直接生成之后上传到服务器上，然后把下载的路径返回，以后需要的话可以直接下载。 UUID是我的一个工具类，用来生成随机的编码的，主要是为了防止生成的二维码的名称重复，为了上传使用。 上面的代码也是比较详细的，如果有不懂的地方可以一起讨论，相互学习，这个是原创，转载的话请注明来源。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://struggling-bird.cn/categories/JavaWeb/"}],"tags":[{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://struggling-bird.cn/tags/Spring/"},{"name":"二维码","slug":"二维码","permalink":"http://struggling-bird.cn/tags/二维码/"}]},{"title":"基于Maven的搭建SSM框架的详细说明","slug":"基于Maven的搭建SSM框架的详细说明","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:39:51.510Z","comments":true,"path":"2018/08/11/基于Maven的搭建SSM框架的详细说明/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/基于Maven的搭建SSM框架的详细说明/","excerpt":"","text":"SSM（Spring+SpringMVC+Mybatis），目前较为主流的企业级架构方案。标准的MVC设计模式，将整个系统划分为显示层、Controller层、Service层、Dao层四层，使用SpringMVC负责请求的转发和视图管理，Spring实现业务对象管理, MyBatis作为数据对象持久化引擎，以上说明来自百度。 这个框架相信对于大家来说都不会太陌生，用的都比较多，本猿作作为一名萌新，入职以来虽然一直都在使用SSM框架但是对于该框架的搭建不是很了解，借此次项目的机会搭建了一次并且成功，很是喜悦，因此记录下来方便以后查看，也为像本猿一样的新人提供一点帮助。 一.环境的准备搭建 首先你需要创建一个maven项目，本猿用的是StS大家可以根据自己的喜好选择。 1.先创建一个maven项目 2.选择该项 3.接下来输入你的项目的名称和包的目录结构 4.然后项目就创建完成了，接下来你需要创建src/main/resources、src/main/java、src/test/resources、src/test/java，创建完之后项目的结构如图所示。 5.然后分别修改输出的路径。 到此，项目的创建工作基本上就完成了，接下里就需要进行框架的整合了，框架的整合我分为两部分来做的，第一部分先整合Spring和Mybatis的框架 ，接下来是整合springMvc的。 二、Spring和Mybatis 我先一次给出我导入的所有的jar包，上面都有很详细的注释的，应该可以看懂的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ssm&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;SSM Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit的测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringmVC包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba 数据源相关jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;0.2.23&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSM&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 1.先配置创建一个xml来放spring和mybatis的配置文件，主要存放的是自动扫描、自动注入和数据库的配置等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162spring-mybatis.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.ssm&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;maxWait&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/ssm/mapper/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.ssm.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 2.配置log日志(此配置方法来自网络) log4j.properties 123456789101112131415161718log4j.rootLogger=INFO,Console,File#定义日志输出目的地为控制台log4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.Target=System.out#可以灵活地指定日志输出格式，下面一行是指定具体的格式log4j.appender.Console.layout = org.apache.log4j.PatternLayoutlog4j.appender.Console.layout.ConversionPattern=[%c] - %m%n#文件大小到达指定尺寸的时候产生一个新的文件log4j.appender.File = org.apache.log4j.RollingFileAppender#指定输出目录log4j.appender.File.File = logs/ssm.log#定义文件最大大小log4j.appender.File.MaxFileSize = 10MB# 输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志log4j.appender.File.Threshold = ALLlog4j.appender.File.layout = org.apache.log4j.PatternLayoutlog4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125;][%c]%m%n 3.配置数据库的连接 jdbc.properties 1234567891011121314driver=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8username=rootpassword=#定义初始连接数initialSize=0#定义最大连接数maxActive=20#定义最大空闲maxIdle=20#定义最小空闲minIdle=1#定义最长等待时间maxWait=60000 到此Spring和mybatis的配置就完成了，接下来就剩下整合SpringMvc了，我先吧所有的配置完成之后再上我的测试代码吧。 三.Spring MVC 的配置 主要是配置自动扫描，和注解的启动和拦截器等。 1.先新建SpringMVC的配置文件。 spring-mvc.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@RestController注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;com.ssm.controller&quot; /&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven &gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;features&quot;&gt; &lt;list&gt; &lt;value&gt;DisableCircularReferenceDetect &lt;/value&gt; &lt;value&gt;WriteMapNullValue&lt;/value&gt; &lt;value&gt;WriteNullListAsEmpty&lt;/value&gt; &lt;value&gt;WriteNullStringAsEmpty&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 四 .接下来是在web.xml中将SpringMVC和前面的东西进行整合。 web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--数据库的配置--&gt; &lt;!-- 配置程序参数文件 --&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 到此，SSM三大框架的整合就全部完成了，现在我上一下我的测试代码，你们可以进行参考。代码","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://struggling-bird.cn/categories/JavaWeb/"}],"tags":[{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://struggling-bird.cn/tags/Spring/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"http://struggling-bird.cn/tags/SpringMvc/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://struggling-bird.cn/tags/MyBatis/"}]},{"title":"基于SpringMVC的文件上传","slug":"基于SpringMVC的文件上传","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:30:00.639Z","comments":true,"path":"2018/08/11/基于SpringMVC的文件上传/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/基于SpringMVC的文件上传/","excerpt":"","text":"由于是一个新手菜鸟，所以说对很多东西都不是很了解，最近刚好在做一个项目需要做文件的上传和下载，以前直接是用写好的，这个自己动手写了一下用了半天时间跟大家分享一下。 一.环境是SSM+Maven 首先，你需要搭建好springMC的环境，如果不会搭建的话请自己百度，他会告诉你的。 二.导入需要的Jar包 因为这个附件的上传和下载是基于SpringMVC做的，因此我们需要导入一下jar包。如下，我直接在pom中引入就可以了。 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; 三.接下来比较重要了，就是需要去配置下你的springMVC的配置文件，配置信息如下。 1234567891011121314151617181920&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 上传文件大小上限，单位为字节（10MB） --&gt; &lt;property name=&quot;maxUploadSize&quot;&gt; &lt;value&gt;10485760&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;defaultEncoding&quot;&gt; &lt;value&gt;UTF-8&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 上传文件大小上限，单位为字节（10MB） --&gt; &lt;property name=&quot;maxUploadSize&quot;&gt; &lt;value&gt;10485760&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;defaultEncoding&quot;&gt; &lt;value&gt;UTF-8&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 四。接下来就是写html界面(最重要的一点是一定要在form中加上 enctype=”multipart/form-data” ) 1234567891011121314151617181920212223&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;文件上传&lt;/h3&gt; &lt;form enctype=&quot;multipart/form-data&quot; action=&quot;http://localhost:8080/yangfan-server/upload&quot; method=&quot;post&quot; &gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;/&gt; 参数inputStr:&lt;input type=&quot;text&quot; name=&quot;des&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt; &lt;/form&gt; &lt;hr/&gt; &lt;h3&gt;文件下载&lt;/h3&gt; &lt;a href=&quot;download?filename=50769870/Desert.jpg&quot;&gt; Penguins.jpg &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 五.接下来就是controller的实现 这个是文件上传的，因为我自己写了一个方法来生成一个随机的路径，你们也可以自己定义自己的路径。 12345678910111213141516171819202122232425262728293031//上传文件会自动绑定到MultipartFile中 @RequestMapping(value=&quot;/upload&quot;,method=&#123;RequestMethod.POST&#125;) public Result upload(HttpServletRequest request, @RequestParam(&quot;des&quot;) String des, @RequestParam(&quot;file&quot;) MultipartFile file) throws Exception &#123; Result result = new Result(); System.out.println(des); //如果文件不为空，写入上传路径 if(!file.isEmpty()) &#123; long uuid = NumberUtil.createId(); //上传文件路径 String path = request.getServletContext().getRealPath(&quot;/images/&quot;) + File.separator + uuid; //上传文件名 String filename = file.getOriginalFilename(); File filepath = new File(path,filename); //判断路径是否存在，如果不存在就创建一个 if (!filepath.getParentFile().exists()) &#123; filepath.getParentFile().mkdirs(); &#125; //将上传文件保存到一个目标文件当中 file.transferTo(new File(path + File.separator +filename)); result.setSuccess(true); result.addDefaultModel(&quot;fileName&quot;, &quot;fileName&quot;); result.addDefaultModel(&quot;fileDownLoad&quot;,uuid+&quot;/&quot;+filename); return result; &#125; else &#123; return result; &#125; &#125; 这个是下载的deomo 12345678910111213141516171819@RequestMapping(value=&quot;/download&quot;,method=&#123;RequestMethod.POST,RequestMethod.GET&#125;) public ResponseEntity&lt;byte[]&gt; download(HttpServletRequest request, @RequestParam(&quot;filename&quot;) String filename, Model model)throws Exception &#123; //下载文件路径 String path = request.getServletContext().getRealPath(&quot;/images/&quot;); File file = new File(path + File.separator + filename); HttpHeaders headers = new HttpHeaders(); //下载显示的文件名，解决中文名称乱码问题 String downloadFielName = new String(filename.getBytes(&quot;UTF-8&quot;),&quot;iso-8859-1&quot;); String[] strArr = downloadFielName.split(&quot;/&quot;); //通知浏览器以attachment（下载方式）打开图片 headers.setContentDispositionFormData(&quot;attachment&quot;, strArr[1]); //application/octet-stream ： 二进制流数据（最常见的文件下载）。 headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED); &#125; 以上就是上传和下载的代码了，不过现在只是上传单个文件的，后续会加上多个文件的批量操作的。 欢迎转载，请注明出处","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://struggling-bird.cn/categories/JavaWeb/"}],"tags":[{"name":"java","slug":"java","permalink":"http://struggling-bird.cn/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://struggling-bird.cn/tags/Spring/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"http://struggling-bird.cn/tags/SpringMvc/"}]},{"title":"程序员的一首诗","slug":"程序员的一首诗","date":"2018-08-11T09:34:31.000Z","updated":"2018-08-11T10:19:36.369Z","comments":true,"path":"2018/08/11/程序员的一首诗/","link":"","permalink":"http://struggling-bird.cn/2018/08/11/程序员的一首诗/","excerpt":"","text":"我能抽象出整个世界..但是我不能抽象你.. 因为你在我心中是那么的具体…所以我的世界并不完整. 我可以重载甚至覆盖这个世界里的任何一种方法…但是我却不能重载对你的思念… 也许命中注定了.你在我的世界里是永远的烙上了静态的属性…而我不慎调用了爱你这个方法.. 当我义无返顾的把自己作为参数传进这个方法时…我才发现爱上你是一个死循环.. 它不停的返回对你的思念压入我的心里的堆栈..在这无尽的黑夜中… 我的内存里已经再也装不下别人…我不停的向系统申请空间..但却捕获一个异常–我爱的人不爱我…为了解决这个异常…我愿意虚拟出最后一点内存..把所有我能实现的方法地址压入堆栈..并且在栈尾压入最后一个方法–将字符串”我爱你，你爱我吗 “传递给你..如果返回的值为真–我将用尽一生去爱你… 否则—我将释放掉所有系统资源…","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://struggling-bird.cn/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://struggling-bird.cn/tags/杂谈/"}]}]}