<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奋斗的小鸟</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-03T04:13:38.357Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>奋斗的小鸟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springboot项目的搭建和基本的用法</title>
    <link href="http://yoursite.com/2018/07/03/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/03/springboot项目的搭建和基本的用法/</id>
    <published>2018-07-03T04:11:36.000Z</published>
    <updated>2018-07-03T04:13:38.357Z</updated>
    
    <content type="html"><![CDATA[<p>初涉springboot，学习小记，用于学习，简单介绍下如何去创建一个简单的的springboot工程。本人这里使用idea操作的。<br><strong>一.首先需要创建一个工程：new project,选择Spring Initalizr。</strong><br><img src="https://img-blog.csdn.net/20180509172029526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输入项目的目录结构和项目的名称，如图：<br><img src="https://img-blog.csdn.net/20180509172333830?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>然后选择你需要导入的jar包，如下：<br><img src="https://img-blog.csdn.net/20180509172423241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>web是web项目的核心启动包，devtools是一个web项目的工具包。</p><p><strong>二.然后你的一个springboot项目便创建完成。</strong><br>如图我们可以创建这个项目的目录结构，但是需要注意一点的是，包的结构必须和TestApplication是在一级上。<br> <img src="https://img-blog.csdn.net/20180509172740232?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在controller里面创建一个类，HelloController</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/hello&quot;)</span><br><span class="line">    public  String sayHello()&#123;</span><br><span class="line">        return  &quot;Hello , my First demo!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然后我们启动这个工程，然后访问一下！</strong><br><img src="https://img-blog.csdn.net/20180509173207746?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如上图所示我们的项目就已经构建完成了，然后具体的项目的热部署和项目的过滤器和测试等都在我下面的笔记中有，也可以看我的github，查看我的代码！</p><p><strong>笔记</strong>：</p><blockquote><p><strong>1.springboot的创建：</strong>     idea的情况下，选择Spring Initializr 然后配置 web 和 devtools 一个是启动的web的核心依赖一个是开发工具包<br><strong>2.创建热部署</strong>     idea下，pom中修改 devtools的optional为true 则为热部署开启     plugin 下增加configuration –》fork 为true     接下来在build<br>里面选择自动构建；ctrl+shift+a：输入register<br>窜则compile.automake.allow.when.app.running<br><strong>3.单元测试</strong>     先创建mockmvc，静态的加载：ockMvcBuilders.standaloneSetup(new HelloWorldController()).build();<br>    mockmvc.perform()调用mockmvcRequestBuilders.post/get方法，.parm()加参数–》键值对类型,anddo（print()）可以打印<br><strong>4json的支持</strong>     在 Spring Boot 体系中，天然对 Json 支持，@restController<br><strong>5.请求传参</strong>     例如@RequestMapping(value=”get/{name}”, method=RequestMethod.GET)     public User get(@PathVariable String name)<br>{         this.name = name;     }<br><strong>6.参数校验</strong>     实体类上可以加@NotEmpty，@Max，@Min，@Length来设置属性的校验     Spring Boot 的参数校验其实是依赖于 hibernate-validator 来进行     public void saveUser(@Valid User<br>user,BindingResult result){         List<objecterror> list =<br>result.getAllErrors(); //能够得到所有的校验的结果     }<br><strong>7.自定义过滤</strong>     自定义的过滤必须实现Filter接口并实现方法，在doFilter里面写上自己的过滤处理     @Configuration说明是个配置类，用来存放配置信息，     @bean 说明该方法作为一个配置信息被spring监控，<br>    public FilterRegistrationBean testFilterRegistration() {<br>       FilterRegistrationBean registration = new FilterRegistrationBean();<br>       registration.setFilter(new MyFilter());<br>       registration.addUrlPatterns(“/*”);<br>       registration.addInitParameter(“paramName”, “paramValue”);<br>       registration.setName(“MyFilter”);<br>       registration.setOrder(1);<br>       return registration;<br>    }</objecterror></p></blockquote><p><a href="https://github.com/zhaokuankuan/springboot-basic" target="_blank" rel="noopener">代码地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初涉springboot，学习小记，用于学习，简单介绍下如何去创建一个简单的的springboot工程。本人这里使用idea操作的。&lt;br&gt;&lt;strong&gt;一.首先需要创建一个工程：new project,选择Spring Initalizr。&lt;/strong&gt;&lt;br&gt;&lt;i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Springcloud微服务架构之服务的注册和发现</title>
    <link href="http://yoursite.com/2018/07/03/Springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/07/03/Springcloud微服务架构之服务的注册和发现/</id>
    <published>2018-07-03T04:11:22.000Z</published>
    <updated>2018-07-03T04:12:47.026Z</updated>
    
    <content type="html"><![CDATA[<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务可以在”自己的程序”中运行，并通过”轻量级设备与HTTP型API进行沟通”。关键在于该服务可以在自己的程序中运行。通过这一点我们就可以将服务公开与微服务架构(在现有系统中分布一个API)区分开来。在服务公开中，许多服务都可以被内部独立进程所限制。如果其中任何一个服务需要增加某种功能，那么就必须缩小进程范围。在微服务架构中，只需要在特定的某种服务中增加所需功能，而不影响整体进程。</strong><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上解释来自百度，综上可以看出对于微服务架构来说，服务的注册和服务的发现就很关键了，由于本人接触Dubbo和zookeeper较少因此谈谈Springcloud的注册和发现把。<br><strong>一.新建一个空的maven工程（任何东西都不选)如图</strong><br><img src="https://img-blog.csdn.net/20180507173152623?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>    Next： 然后填写 GroupId 和 ArtifactId 分别写入的是 包的层次结构基本上是公司的域名或者项目的域名。例 com.kk 或者  com.baidu等<br><strong>二.在新建好的该maven项目中新建两个module分别为server和service作为服务的注册中心和服务的提供方(创建方法类似)。</strong><br><img src="https://img-blog.csdn.net/2018050717322387?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180507173256574?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180507173310227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180507173322191?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>注册中心选择server  , 服务提供者选择discovery<br><strong>三.Server的配置，创建一个application.yml文件</strong><br>然后配置yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #表示是否将自己注册到Eureka Server</span><br><span class="line">    fetch-registry: false #表示是否从Eureka Server获取注册信息</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/   #注册中心的地址</span><br></pre></td></tr></table></figure><p>然后启动server的这个项目，访问<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a>   你就看到如下的界面<br><img src="https://img-blog.csdn.net/2018050717333577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>说明注册中心已经配置完成，只是里面没有注册服务。<br>Ps：在这里说一下，因为我们在做分布式部署的时候为了保证项目的健壮性我们通常会采用集群部署，因为可以参考微笑的博客来设置注册中心的集群。<br><strong>四.接下来我们应该向注册中心注册服务了，首先创建application.yml文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在ServiceApplication类中开启服务发现的注解</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public class ServiceApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(ServiceApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配置yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`server:</span><br><span class="line">  port: 8762 #设置服务的端口号</span><br><span class="line">client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-A</span><br></pre></td></tr></table></figure><p>`<br>然后再次访问注册中心，你就发现我们的服务已经注册进去了。<br><img src="https://img-blog.csdn.net/20180507173351441?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>到此，springcloud的服务的注册和发现已经完成。</strong><br>在此感谢，两位大佬的博客，我是根据以上大佬的博客学习的！<br><a href="https://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">方志鹏的springcloud微服务架构</a><br><a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">纯洁的微笑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;微服务可以在”自己的程序”中运行，并通过”轻量级设备与HTTP型API进行沟通”。关键在于该服务可以在自己的程序中运行。通过这一点我们就可以将服务公开与微服务架构(在现有系统中分布一个API)区分开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud微服务架构之服务的调用</title>
    <link href="http://yoursite.com/2018/07/03/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/03/SpringCloud微服务架构之服务的调用/</id>
    <published>2018-07-03T04:10:50.000Z</published>
    <updated>2018-07-03T04:12:31.730Z</updated>
    
    <content type="html"><![CDATA[<p><strong>微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。接下来分别对这两种的进行讲解。服务的调用还是在上一节<a href="https://blog.csdn.net/zhaokk_git/article/details/80228880" target="_blank" rel="noopener">服务的注册和发现</a>的基础上进行的。</strong><br>一．    <strong>准备工作，</strong>服务的调用基于上一节，服务的注册和发现进行的，因此我们需要先启动上一节的服务注册中心，然后再启动我们需要注册的服务service-hi,然后修改service 的端口号重新启动，访问<strong><a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></strong>，你会看到如下图则表示我们的准备工作已经完成了。<br> <img src="https://img-blog.csdn.net/20180509170634707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>二．    <strong>创建一个基于Ribbon+restTemplate的服务消费者：ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。</strong></p><ol><li><p>新建一个module，分别引入如下的包，然后finish</p><p><img src="https://img-blog.csdn.net/20180509170646527?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2.新建好了之后，RibbonApplication中增加注解@bean 将RestTemplate注入到容器中去，</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class RibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(RibbonApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   @LoadBalanced</span><br><span class="line">   public RestTemplate restTemplate()&#123;</span><br><span class="line">      return  new RestTemplate();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，然后创建一个service类和一个controller类，如图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class service &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public  String  sayHello(String name)&#123;</span><br><span class="line">        return  this.restTemplate.getForObject(&quot;http://service-hi/hi?name=&quot; + name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service中需要注入的是resttemplate接口,并且可以去访问对应的服务和服务的接口。<br>在创建一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class controller &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private service service;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)</span><br><span class="line">    public String sayHello(String name)&#123;</span><br><span class="line">        return  service.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4，接下来我们需要修改下我们前一节所写的服务，如图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@RestController</span><br><span class="line">public class ServiceApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(ServiceApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">   String port;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(value = &quot;/hi&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)</span><br><span class="line">   public String sayHello(String name)&#123;</span><br><span class="line">      return &quot;I am service-hi ,my port is :&quot; + port + &quot;my name is &quot; + name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5，然后一次重启所有的服务：serverservice1service2Ribbon,然后访问<strong><a href="http://localhost:8080/hello?name=kk" target="_blank" rel="noopener">http://localhost:8080/hello?name=kk</a></strong>,你会发现界面上会重复交替出现两个服务service1和service2的端口号和传递过去的参数。<br><img src="https://img-blog.csdn.net/20180509170728714?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>到此Ribbon和restTemplate的消费服务已经完成，接下来我们看看Feign的服务。<br>三．    <strong>创建一个基于Feign去消费服务</strong>：<br>Feign 采用的是基于接口的注解<br>Feign 整合了ribbon<br>1.同理我们也是需要在一的步骤下进行的，必须先开启服务注册中心，并且将我们的服务注册进去，然后新建一个Feign，如图：<br><img src="https://img-blog.csdn.net/20180509170739928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>然后需要创建一个Iservice接口和FeignController类:<br>创建该接口用来调用服务@FeignClient(value = “service-hi”) 注解配置的是服务的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/hi&quot;) //配置的调用的接口</span><br><span class="line">@FeignClient(value = &quot;service-hi&quot;)</span><br><span class="line">@Service</span><br><span class="line">public interface Iservice &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hi&quot;)</span><br><span class="line">     String SayHello(@RequestParam(value = &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class FeignController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Iservice iservice;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/feign/hello&quot;)</span><br><span class="line">    public String sayHello(String name)&#123;</span><br><span class="line">        return   iservice.SayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置下该启动类，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class FeignApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(FeignApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后访问：<strong><a href="http://localhost:8080/feign/hello?name=kk" target="_blank" rel="noopener">http://localhost:8080/feign/hello?name=kk</a></strong><br>你会看到如下的界面：<br><img src="https://img-blog.csdn.net/20180509170752523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><strong>以上就是服务的消费的两种方式。</strong> </p><p>附上我的完整的博文：<br><strong><a href="https://blog.csdn.net/zhaokk_git/article/details/80228420" target="_blank" rel="noopener">从零开始学习SpringCloud</a></strong><br><strong><a href="https://github.com/zhaokuankuan/springcloud/tree/master/springcloud" target="_blank" rel="noopener">代码地址</a></strong><br><strong>在此感谢，两位大佬的博客，我是根据以上大佬的博客学习的！</strong><br><a href="https://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">方志鹏的springcloud微服务架构</a><br><a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">纯洁的微笑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。接下来分别对这两种的进行讲解。服务的调用还是在上一节
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Springcloud微服务架构之断路器(Hystrix)</title>
    <link href="http://yoursite.com/2018/07/03/Springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%96%AD%E8%B7%AF%E5%99%A8-Hystrix/"/>
    <id>http://yoursite.com/2018/07/03/Springcloud微服务架构之断路器-Hystrix/</id>
    <published>2018-07-03T04:10:31.000Z</published>
    <updated>2018-07-03T04:12:17.209Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用，详细使用见<a href="https://blog.csdn.net/zhaokk_git/article/details/80256356" target="_blank" rel="noopener">上一章</a>。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。为了将这种影响降到最低，提出了断路器的概念</strong><br><strong>一．    断路器介绍</strong><br>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。<br>当较底层的服务出现故障时，会导致连锁故障。当一个服务的不可用达到一定的阈值断路器将会被打开。<br><img src="https://img-blog.csdn.net/20180510151201743?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>断路打开后，可用避免连锁故障，fallback方法返回一个出现故障时的处理方法<br><strong>二．    接下来便分别对Ribbon+resttemplate和feign两种消费服务的方式分别使用断路器进行说明。</strong><br>在此应该首先启动上一节中的服务注册中心和需要注册的服务server和service。<br>Server的端口号是8761，server1和server2的端口号分别是8762和8763。<br><strong>三．    在Ribbon+resttemplate中使用断路器</strong><br>a)    需要先引入断路器的依赖包，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--断路器的依赖包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>b)    在程序的启动类中开启断路器的注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrix</span><br><span class="line">public class RibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(RibbonApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   @LoadBalanced</span><br><span class="line">   public RestTemplate restTemplate()&#123;</span><br><span class="line">      return  new RestTemplate();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c)    修改调用服务的方法Service，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class service &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @HystrixCommand(fallbackMethod = &quot;hasError&quot; )</span><br><span class="line">    public  String  sayHello(String name)&#123;</span><br><span class="line">        return  this.restTemplate.getForObject(&quot;http://service-hi/hi?name=&quot; + name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String hasError(String name)&#123;</span><br><span class="line">        return  &quot;I have a error, so You must restart me!&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d)    然后停掉第一步启动的两个service1和service2,再次访问<strong><a href="http://localhost:8080/hello?name=kk" target="_blank" rel="noopener">http://localhost:8080/hello?name=kk</a></strong>，会出现如下图的界面<br> <img src="https://img-blog.csdn.net/20180510145048845?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>即，断路器增加成功！当你再次启动一个服务，如server1时，访问上述地址，会得到如下的图示：</p><p><strong>四．    在feign中使用断路器</strong>：<br>Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：<br>feign.hystrix.enabled=true<br>a)    这个只需要修改接口即可，在上节的基础上我们修改Iserver，首先需要创建一个类实现Iservice接口的方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class IserviceImpl implements Iservice &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String SayHello(String name) &#123;</span><br><span class="line">        return  &quot;I have a error, so You must restart me!&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b)    然后在修改Iservice中修该fallback指向刚才的实现类，当出现断路时会调用实现类中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = &quot;service-hi&quot;,fallback = IserviceImpl.class)</span><br><span class="line">@Service</span><br><span class="line">public interface Iservice &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hi&quot;)</span><br><span class="line">    String SayHello(@RequestParam(value = &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c)    然后访问，出现我们负载均衡的调用service1和service2，如下图：<br><img src="https://img-blog.csdn.net/20180510150843425?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>d)    然后我们停掉service2和service2，再次访问上述的路径，会出现如下图的显示，即说明断路器发挥了作用。<br><img src="https://img-blog.csdn.net/20180510150923308?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><strong>五.  断路器仪表盘</strong><br>    这里ribbon和feign两中方式都可以进行，我这里以feign为例，ribbon的和这个一样。<br>a)    首先我们需要在pom中引入，该仪表盘的依赖，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.4.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>b)    然后在Application上加上注释，开启注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class FeignApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(FeignApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动feign,访问该网址<strong><a href="http://localhost:8080/hystrix" target="_blank" rel="noopener">http://localhost:8080/hystrix</a></strong>，出现图示的界面，<br> <img src="https://img-blog.csdn.net/20180510150940272?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>附上我的完整的博文：<br><strong><a href="https://blog.csdn.net/zhaokk_git/article/details/80228420" target="_blank" rel="noopener">从零开始学习SpringCloud</a></strong><br><strong><a href="https://github.com/zhaokuankuan/springcloud/tree/master/springcloud" target="_blank" rel="noopener">代码地址</a></strong><br><strong>在此感谢，两位大佬的博客，我是根据以上大佬的博客学习的！</strong><br><a href="https://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">方志鹏的springcloud微服务架构</a><br><a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">纯洁的微笑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用，详细使用见&lt;a href=&quot;https://blog.csdn.net/zhaokk
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从零开始学习SpringCloud</title>
    <link href="http://yoursite.com/2018/07/03/Springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3(zuul)/"/>
    <id>http://yoursite.com/2018/07/03/Springcloud微服务架构之路由网关(zuul)/</id>
    <published>2018-07-03T04:08:24.000Z</published>
    <updated>2018-07-03T04:09:50.798Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Springcloud微服务架构之路由网关(zuul)</strong></p><p><strong>Zuul的主要功能是路由转发和过滤器:</strong><br>    <strong>1.路由功能是微服务的一部分</strong>，比如将 API-A转发到service-hi服务,zuul默认和Ribbon结合        实现了负载均衡的功能。<br>    <strong>2.zuul不仅只是路由，并且还能过滤，做一些安全验证</strong>。</p><hr><p><strong>一．    接下来我们分别看一下，Zuul的路由转发和过滤器</strong><br>        首先还是在上一节的<a href="https://blog.csdn.net/zhaokk_git/article/details/80228880" target="_blank" rel="noopener">服务的注册和发现</a>的基础上进行的，我们需要先启动Server(服务的注册中心):8761，然后启动我们的一个服务Service(需要注册的服务):8762。<br><strong>二．    路由转发：路由功能是微服务的一部分，比如将API-A转发到service-hi</strong><br><strong>a)    创建一个module项目rest-client</strong><br> <img src="https://img-blog.csdn.net/2018052415363735?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>b)    然后新建一个appliacation.yml,</strong>配置内容如下，我们将这个服务注册进eureka注册中心中，然后设置zuul的路由，当访问API-A 的时候我们将请求的理由到service-HI服务中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8088</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">     defaultZone: http://localhost:8761/eureka</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-zuul</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    API-A:</span><br><span class="line">      path: /API-A/**</span><br><span class="line">      serviceId: SERVICE-HI</span><br></pre></td></tr></table></figure><p><strong>c)   然后我们修改RestClientApplication 这个类，增加zuul开启路由的注解</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableZuulProxy</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public class RestClientApplication &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(RestClientApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>d)    分别访问<a href="http://localhost:8761/你会看到如下的图示" target="_blank" rel="noopener">http://localhost:8761/你会看到如下的图示</a></strong>，有我们注入的zuul和需要路由的serice-hi服务。<br> <img src="https://img-blog.csdn.net/2018052415365712?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在访问<strong><a href="http://localhost:8088/API-A/hello?name=kk" target="_blank" rel="noopener">http://localhost:8088/API-A/hello?name=kk</a></strong>，你会看到，我们的如图所示，即我们的路由已经成功的将api-a转发到了serive-hi的服务，并且输出了service-hi的端口，具体的代码可以看<strong>文章的结尾</strong>。</p><p><img src="https://img-blog.csdn.net/20180524153705952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>三   过滤功能：zuul不仅可以做为路由使用，还可以用作过滤来做一些逻辑操作</strong><br><strong>a)    在上面的基础上进行改造，创建一个类MyFilter具体的说明已经注释出来了。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author :zhaokk</span><br><span class="line"> * @date: 2018/5/11 - 14:58</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class MyFilter extends ZuulFilter &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(ZuulFilter.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;pre&quot;;</span><br><span class="line">        //pre：路由之前</span><br><span class="line">        //routing：路由之时</span><br><span class="line">        //post： 路由之后</span><br><span class="line">        //error：发送错误调用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 0;   //优先级  0 最高</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true; //true为永远过滤</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() throws ZuulException &#123;</span><br><span class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest httpServletRequest = requestContext.getRequest();</span><br><span class="line">        Object o = httpServletRequest.getParameter(&quot;token&quot;);</span><br><span class="line">        if(o == null)&#123;</span><br><span class="line">            logger.warn(&quot;token is empty&quot;);</span><br><span class="line">            requestContext.setSendZuulResponse(false);</span><br><span class="line">            requestContext.setResponseStatusCode(401);</span><br><span class="line">            try &#123;</span><br><span class="line">                requestContext.getResponse().getWriter().write(&quot;token is empty!&quot;);</span><br><span class="line">            &#125;catch (Throwable throwable)&#123;</span><br><span class="line">                return  null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(&quot;ok&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>b)    然后我们继续访问<a href="http://localhost:8088/API-A/hello?name=kk" target="_blank" rel="noopener">http://localhost:8088/API-A/hello?name=kk</a></strong>，这时你会看到，界面如图，因为我们的代码中获取不到token，所以被拦截了，<br><img src="https://img-blog.csdn.net/20180524153718401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> <strong>c） 当我们输入<a href="http://localhost:8088/API-A/hello?name=kk&amp;token=22" target="_blank" rel="noopener">http://localhost:8088/API-A/hello?name=kk&amp;token=22</a></strong>，会显示 如下的界面，即我们的过滤功能有效了！<br><img src="https://img-blog.csdn.net/20180524153724592?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ra19naXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>附上我的完整的博文：<br><strong><a href="https://blog.csdn.net/zhaokk_git/article/details/80228420" target="_blank" rel="noopener">从零开始学习SpringCloud</a></strong><br><strong><a href="https://github.com/zhaokuankuan/springcloud/tree/master/SpringCloudZuul" target="_blank" rel="noopener">代码地址</a></strong><br><strong>在此感谢，两位大佬的博客，我是根据以上大佬的博客学习的！</strong><br> <a href="https://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">方志鹏的springcloud微服务架构</a><br> <a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">纯洁的微笑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Springcloud微服务架构之路由网关(zuul)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zuul的主要功能是路由转发和过滤器:&lt;/strong&gt;&lt;br&gt;    &lt;strong&gt;1.路由功能是微服务的一部分&lt;/strong&gt;，比如将 API-A
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从零开始学习SpringCloud</title>
    <link href="http://yoursite.com/2018/07/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0SpringCloud/"/>
    <id>http://yoursite.com/2018/07/03/从零开始学习SpringCloud/</id>
    <published>2018-07-03T04:08:24.000Z</published>
    <updated>2018-07-03T04:08:39.549Z</updated>
    
    <content type="html"><![CDATA[<p><strong>&#160; &#160; &#160;前段时间把SpringBoot刷了一遍，感觉是时候深入研究一下微服务架构了，在网上看到了方志鹏的书，觉得不错便关注了他的博客，由于前期一直关注微笑并且跟着微笑的达人课完成了SpringBoot的入门，因此在此感谢两位大佬，令附上两位大佬的博客地址。</strong> ==》<strong><a href="https://blog.csdn.net/zhaokk_git/article/details/79608197" target="_blank" rel="noopener">springboot的入门</a></strong><br>  &#160; &#160; &#160;我将springcloud处理微服务架构分为下面的模块进行慢慢的蚕食：<br>  &#160; &#160; &#160;1. <a href="https://blog.csdn.net/zhaokk_git/article/details/80228880" target="_blank" rel="noopener">服务的注册和发现</a><br>  &#160; &#160; &#160;2.  <a href="https://blog.csdn.net/zhaokk_git/article/details/80267799" target="_blank" rel="noopener">断路器</a><br> &#160; &#160; &#160;3. <a href="https://blog.csdn.net/zhaokk_git/article/details/80256356" target="_blank" rel="noopener">服务调用</a><br>&#160; &#160; &#160;4. <a href="https://blog.csdn.net/zhaokk_git/article/details/80435355" target="_blank" rel="noopener">路由网关</a><br> &#160; &#160; &#160;5. 分布式配置中心<br> &#160; &#160; &#160;6. 消息总线<br> &#160; &#160; &#160;7. 服务链路追踪<br> &#160; &#160; &#160;<br>  <strong>&#160; &#160; &#160;未完待续中。。。</strong></p><p>  &#160; &#160; &#160;附上我的github地址，<a href="https://github.com/zhaokuankuan/springcloud" target="_blank" rel="noopener">从零开始学习springcloud</a><br> <strong>以下是我自己对上述模块的认识和分析：</strong></p><blockquote><p> &#160; &#160; &#160;1. 在服务的注册和发现和调用之间有三个模块： 注册中心,服务提供者，服务消费者  &#160;<br>&#160; &#160;2. 启动的时候先启动注册中心==》提供者==》消费者  &#160; &#160;<br>&#160;3.可以对注册中心进行负载均衡也可以对服务的调用进行负载均衡对注册中心：通过修改 <code>defaultZone:http://localhost:8761/eureka/，http://localhost:8762/eureka/，http://localhost:8763/eureka/</code>来实现<br>&#160; &#160; &#160;对服务的调用： ribbon + resttmplate 是客户端的一种负载均衡的方式<br>&#160; &#160; &#160;feign :原理也是基于ribbon实现的。只需要创建一个接口并注解。它具有可插拔的注解特<br>性，可使用Feign<br>注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。<br>&#160; &#160; &#160;4.<br>断路器：为了保证服务的高可用，引入了断路器的概念，当访问一个服务的不可用得到了一定的阈值时，断路器将会被打开<br>    &#160; &#160; &#160;两种实现：<br>         &#160; &#160; &#160;   (1).restTemplate 和 ribbon 方式，需要在调用的服务上增加熔断的方法即可<br>      &#160; &#160; &#160;      (2).feign，需要在接口的FeignClient注解中增加callback方法即可，指向该接口的实现类，该实现类中重写的方法即出现断路时调用的方法。<br>&#160; &#160; &#160;5.路由网关<br>(zuul)：主要做的是路由的转发和过滤，zuul默认和Ribbon结合实现了负载均衡的功能。<br>      &#160; &#160; &#160;      (1).路由的转发，类似于nigix反向代理，将对应的路径代理到对应的服务器上去<br>         &#160; &#160; &#160;   (2).路由的过滤，通过自定义过滤器，然后继承zuulfilter来自定义过滤的类型和优先级和逻辑等 &#160; &#160;<br>&#160;6.分布式配置中心(Configure)：在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件<br>          &#160; &#160; &#160;  分为两个角色：分别是配置的服务器和配置的客户端<br>            &#160; &#160; &#160;延伸到微服务可以将配置中心做成一个微服务，并且将其集群 &#160; &#160;<br>&#160;7.消息总线(Bus)：消息总线将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控<br>                &#160; &#160; &#160;主要是rabbitmq的用法 &#160; &#160; &#160;8.服务链路追踪(Sleuth):在分布式系统中提供追踪解决方案<br>            &#160; &#160; &#160;  对于微服务架构，启动的时候会启动一个Trace，一系列spans组成的一个树状结构<br>             &#160; &#160; &#160;  在访问的时候会跟随目前访问的位置和所用的时间，可以快速的反应和查找问题<br>               &#160; &#160; &#160;  ZipkinServer ==》用来收集调用信息 &#160; &#160; &#160; 9.docker部署springcloud项目 &#160; &#160;<br>&#160;10.服务注册(consul):它是一个提供服务发现和配置的工具,consul具有分布式、高可用、高扩展性。</p></blockquote><p><strong>以上学习资源来自：</strong><br><a href="https://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">方志鹏的springcloud微服务架构</a><br><a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">纯洁的微笑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&amp;#160; &amp;#160; &amp;#160;前段时间把SpringBoot刷了一遍，感觉是时候深入研究一下微服务架构了，在网上看到了方志鹏的书，觉得不错便关注了他的博客，由于前期一直关注微笑并且跟着微笑的达人课完成了SpringBoot的入门，因此在此感谢两位大
      
    
    </summary>
    
    
  </entry>
  
</feed>
